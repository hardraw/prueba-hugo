import { Text, Inline } from 'slate';
import isHotkey from 'is-hotkey';
import EditList from 'slate-edit-list';
import EditTable from 'slate-edit-table';

const SoftBreak = function SoftBreak() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    onKeyDown(event, change) {
      if (options.shift && !isHotkey('shift+enter', event)) return;
      if (!options.shift && !isHotkey('enter', event)) return;
      const onlyIn = options.onlyIn,
            ignoreIn = options.ignoreIn,
            _options$defaultBlock = options.defaultBlock,
            defaultBlock = _options$defaultBlock === void 0 ? 'paragraph' : _options$defaultBlock;
      const _change$value$startBl = change.value.startBlock,
            type = _change$value$startBl.type,
            text = _change$value$startBl.text;
      if (onlyIn && !onlyIn.includes(type)) return;
      if (ignoreIn && ignoreIn.includes(type)) return;
      const shouldClose = text.endsWith('\n');

      if (shouldClose) {
        return change.deleteBackward(1).insertBlock(defaultBlock);
      }

      const textNode = Text.create('\n');
      const breakNode = Inline.create({
        type: 'break',
        nodes: [textNode]
      });
      return change.insertInline(breakNode).insertText('').collapseToStartOfNextText();
    }

  };
};

const SoftBreakOpts = {
  onlyIn: ['quote', 'code']
};
export const SoftBreakConfigured = SoftBreak(SoftBreakOpts);
export const ParagraphSoftBreakConfigured = SoftBreak({
  onlyIn: ['paragraph'],
  shift: true
});

const BreakToDefaultBlock = (_ref) => {
  let _ref$onlyIn = _ref.onlyIn,
      onlyIn = _ref$onlyIn === void 0 ? [] : _ref$onlyIn,
      _ref$defaultBlock = _ref.defaultBlock,
      defaultBlock = _ref$defaultBlock === void 0 ? 'paragraph' : _ref$defaultBlock;
  return {
    onKeyDown(event, change) {
      const value = change.value;
      if (!isHotkey('enter', event) || value.isExpanded) return;

      if (onlyIn.includes(value.startBlock.type)) {
        return change.insertBlock(defaultBlock);
      }
    }

  };
};

const BreakToDefaultBlockOpts = {
  onlyIn: ['heading-one', 'heading-two', 'heading-three', 'heading-four', 'heading-five', 'heading-six']
};
export const BreakToDefaultBlockConfigured = BreakToDefaultBlock(BreakToDefaultBlockOpts);

const BackspaceCloseBlock = function BackspaceCloseBlock() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    onKeyDown(event, change) {
      if (event.key !== 'Backspace') return;
      const _options$defaultBlock2 = options.defaultBlock,
            defaultBlock = _options$defaultBlock2 === void 0 ? 'paragraph' : _options$defaultBlock2,
            ignoreIn = options.ignoreIn,
            onlyIn = options.onlyIn;
      const startBlock = change.value.startBlock;
      const type = startBlock.type;
      if (onlyIn && !onlyIn.includes(type)) return;
      if (ignoreIn && ignoreIn.includes(type)) return;

      if (startBlock.text === '') {
        return change.setBlocks(defaultBlock).focus();
      }
    }

  };
};

const BackspaceCloseBlockOpts = {
  ignoreIn: ['paragraph', 'list-item', 'bulleted-list', 'numbered-list', 'table', 'table-row', 'table-cell']
};
export const BackspaceCloseBlockConfigured = BackspaceCloseBlock(BackspaceCloseBlockOpts);
const EditListOpts = {
  types: ['bulleted-list', 'numbered-list'],
  typeItem: 'list-item'
};
export const EditListConfigured = EditList(EditListOpts);
const EditTableOpts = {
  typeTable: 'table',
  typeRow: 'table-row',
  typeCell: 'table-cell'
};
export const EditTableConfigured = EditTable(EditTableOpts);
const plugins = [SoftBreakConfigured, ParagraphSoftBreakConfigured, BackspaceCloseBlockConfigured, BreakToDefaultBlockConfigured, EditListConfigured];
export default plugins;