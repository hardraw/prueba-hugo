function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import PropTypes from 'prop-types';
import { ClassNames } from '@emotion/core';
import olStyles from 'ol/ol.css';
import Map from 'ol/Map.js';
import View from 'ol/View.js';
import GeoJSON from 'ol/format/GeoJSON';
import Draw from 'ol/interaction/Draw.js';
import TileLayer from 'ol/layer/Tile.js';
import VectorLayer from 'ol/layer/Vector.js';
import OSMSource from 'ol/source/OSM.js';
import VectorSource from 'ol/source/Vector.js';
const formatOptions = {
  dataProjection: 'EPSG:4326',
  featureProjection: 'EPSG:3857'
};

const getDefaultFormat = () => new GeoJSON(formatOptions);

const getDefaultMap = (target, featuresLayer) => new Map({
  target,
  layers: [new TileLayer({
    source: new OSMSource()
  }), featuresLayer],
  view: new View({
    center: [0, 0],
    zoom: 2
  })
});

export default function withMapControl() {
  var _class, _temp;

  let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      getFormat = _ref.getFormat,
      getMap = _ref.getMap;

  return _temp = _class = class MapControl extends React.Component {
    constructor(props) {
      super(props);
      this.mapContainer = React.createRef();
    }

    componentDidMount() {
      const _this$props = this.props,
            field = _this$props.field,
            onChange = _this$props.onChange,
            value = _this$props.value;
      const format = getFormat ? getFormat(field) : getDefaultFormat(field);
      const features = value ? [format.readFeature(value)] : [];
      const featuresSource = new VectorSource({
        features,
        wrapX: false
      });
      const featuresLayer = new VectorLayer({
        source: featuresSource
      });
      const target = this.mapContainer.current;
      const map = getMap ? getMap(target, featuresLayer) : getDefaultMap(target, featuresLayer);

      if (features.length > 0) {
        map.getView().fit(featuresSource.getExtent(), {
          maxZoom: 16,
          padding: [80, 80, 80, 80]
        });
      }

      const draw = new Draw({
        source: featuresSource,
        type: field.get('type', 'Point')
      });
      map.addInteraction(draw);
      const writeOptions = {
        decimals: field.get('decimals', 7)
      };
      draw.on('drawend', (_ref2) => {
        let feature = _ref2.feature;
        featuresSource.clear();
        onChange(format.writeGeometry(feature.getGeometry(), writeOptions));
      });
    }

    render() {
      return React.createElement(ClassNames, null, (_ref3) => {
        let cx = _ref3.cx,
            css = _ref3.css;
        return React.createElement("div", {
          className: cx(this.props.classNameWrapper, css`
                  ${olStyles};
                  padding: 0;
                  overflow: hidden;
                `),
          ref: this.mapContainer
        });
      });
    }

  }, _defineProperty(_class, "propTypes", {
    onChange: PropTypes.func.isRequired,
    field: PropTypes.object.isRequired,
    value: PropTypes.node
  }), _defineProperty(_class, "defaultProps", {
    value: ''
  }), _temp;
}