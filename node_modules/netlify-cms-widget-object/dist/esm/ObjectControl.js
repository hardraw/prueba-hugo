function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import PropTypes from 'prop-types';
import ImmutablePropTypes from 'react-immutable-proptypes';
import { ClassNames } from '@emotion/core';
import { Map, List } from 'immutable';
import { ObjectWidgetTopBar, lengths } from 'netlify-cms-ui-default';
const styleStrings = {
  nestedObjectControl: `
    padding: 6px 14px 14px;
    border-top: 0;
    border-top-left-radius: 0;
    border-top-right-radius: 0;
  `,
  objectWidgetTopBarContainer: `
    padding: ${lengths.objectWidgetTopBarContainerPadding}
  `
};
export default class ObjectControl extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "componentValidate", {});

    _defineProperty(this, "validate", () => {
      const field = this.props.field;
      let fields = field.get('field') || field.get('fields');
      fields = List.isList(fields) ? fields : List([fields]);
      fields.forEach(field => {
        if (field.get('widget') === 'hidden') return;
        this.componentValidate[field.get('name')]();
      });
    });

    _defineProperty(this, "handleCollapseToggle", () => {
      this.setState({
        collapsed: !this.state.collapsed
      });
    });

    _defineProperty(this, "renderFields", (multiFields, singleField) => {
      if (multiFields) {
        return multiFields.map((f, idx) => this.controlFor(f, idx));
      }

      return this.controlFor(singleField);
    });

    this.state = {
      collapsed: false
    };
  }
  /*
   * Always update so that each nested widget has the option to update. This is
   * required because ControlHOC provides a default `shouldComponentUpdate`
   * which only updates if the value changes, but every widget must be allowed
   * to override this.
   */


  shouldComponentUpdate() {
    return true;
  }

  controlFor(field, key) {
    const _this$props = this.props,
          value = _this$props.value,
          onChangeObject = _this$props.onChangeObject,
          onValidateObject = _this$props.onValidateObject,
          clearFieldErrors = _this$props.clearFieldErrors,
          metadata = _this$props.metadata,
          fieldsErrors = _this$props.fieldsErrors,
          EditorControl = _this$props.editorControl,
          controlRef = _this$props.controlRef;

    if (field.get('widget') === 'hidden') {
      return null;
    }

    const fieldName = field.get('name');
    const fieldValue = value && Map.isMap(value) ? value.get(fieldName) : value;
    return React.createElement(EditorControl, {
      key: key,
      field: field,
      value: fieldValue,
      onChange: onChangeObject,
      clearFieldErrors: clearFieldErrors,
      fieldsMetaData: metadata,
      fieldsErrors: fieldsErrors,
      onValidate: onValidateObject,
      processControlRef: controlRef && controlRef.bind(this),
      controlRef: controlRef
    });
  }

  render() {
    const _this$props2 = this.props,
          field = _this$props2.field,
          forID = _this$props2.forID,
          classNameWrapper = _this$props2.classNameWrapper,
          forList = _this$props2.forList;
    const collapsed = this.state.collapsed;
    const multiFields = field.get('fields');
    const singleField = field.get('field');

    if (multiFields || singleField) {
      return React.createElement(ClassNames, null, (_ref) => {
        let css = _ref.css,
            cx = _ref.cx;
        return React.createElement("div", {
          id: forID,
          className: cx(classNameWrapper, css`
                  ${styleStrings.objectWidgetTopBarContainer}
                `, {
            [css`
                    ${styleStrings.nestedObjectControl}
                  `]: forList
          })
        }, forList ? null : React.createElement(ObjectWidgetTopBar, {
          collapsed: collapsed,
          onCollapseToggle: this.handleCollapseToggle
        }), collapsed ? null : this.renderFields(multiFields, singleField));
      });
    }

    return React.createElement("h3", null, "No field(s) defined for this widget");
  }

}

_defineProperty(ObjectControl, "propTypes", {
  onChangeObject: PropTypes.func.isRequired,
  onValidateObject: PropTypes.func.isRequired,
  value: PropTypes.oneOfType([PropTypes.node, PropTypes.object, PropTypes.bool]),
  field: PropTypes.object,
  forID: PropTypes.string,
  classNameWrapper: PropTypes.string.isRequired,
  forList: PropTypes.bool,
  controlRef: PropTypes.func,
  editorControl: PropTypes.func.isRequired,
  resolveWidget: PropTypes.func.isRequired,
  clearFieldErrors: PropTypes.func.isRequired,
  fieldsErrors: ImmutablePropTypes.map.isRequired
});

_defineProperty(ObjectControl, "defaultProps", {
  value: Map()
});