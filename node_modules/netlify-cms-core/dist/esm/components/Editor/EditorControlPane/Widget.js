function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import PropTypes from 'prop-types';
import React, { Component } from 'react';
import ImmutablePropTypes from 'react-immutable-proptypes';
import { Map, List } from 'immutable';
import ValidationErrorTypes from "../../../constants/validationErrorTypes";

const truthy = () => ({
  error: false
});

const isEmpty = value => value === null || value === undefined || value.hasOwnProperty('length') && value.length === 0 || value.constructor === Object && Object.keys(value).length === 0 || List.isList(value) && value.size === 0;

export default class Widget extends Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "processInnerControlRef", ref => {
      if (!ref) return;
      /**
       * If the widget is a container that receives state updates from the store,
       * we'll need to get the ref of the actual control via the `react-redux`
       * `getWrappedInstance` method. Note that connected widgets must pass
       * `withRef: true` to `connect` in the options object.
       */

      this.innerWrappedControl = ref.getWrappedInstance ? ref.getWrappedInstance() : ref;
      this.wrappedControlValid = this.innerWrappedControl.isValid || truthy;
      /**
       * Get the `shouldComponentUpdate` method from the wrapped control, and
       * provide the control instance is the `this` binding.
       */

      const scu = this.innerWrappedControl.shouldComponentUpdate;
      this.wrappedControlShouldComponentUpdate = scu && scu.bind(this.innerWrappedControl);
    });

    _defineProperty(this, "validate", function () {
      let skipWrapped = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      const _this$props = _this.props,
            field = _this$props.field,
            value = _this$props.value;
      const errors = [];
      const validations = [_this.validatePresence, _this.validatePattern];
      validations.forEach(func => {
        const response = func(field, value);
        if (response.error) errors.push(response.error);
      });

      if (skipWrapped) {
        if (skipWrapped.error) errors.push(skipWrapped.error);
      } else {
        const wrappedError = _this.validateWrappedControl(field);

        if (wrappedError.error) errors.push(wrappedError.error);
      }

      _this.props.onValidate(errors);
    });

    _defineProperty(this, "validatePresence", (field, value) => {
      const t = this.props.t;
      const isRequired = field.get('required', true);

      if (isRequired && isEmpty(value)) {
        const error = {
          type: ValidationErrorTypes.PRESENCE,
          message: t('editor.editorControlPane.widget.required', {
            fieldLabel: field.get('label', field.get('name'))
          })
        };
        return {
          error
        };
      }

      return {
        error: false
      };
    });

    _defineProperty(this, "validatePattern", (field, value) => {
      const t = this.props.t;
      const pattern = field.get('pattern', false);

      if (isEmpty(value)) {
        return {
          error: false
        };
      }

      if (pattern && !RegExp(pattern.first()).test(value)) {
        const error = {
          type: ValidationErrorTypes.PATTERN,
          message: t('editor.editorControlPane.widget.regexPattern', {
            fieldLabel: field.get('label', field.get('name')),
            pattern: pattern.last()
          })
        };
        return {
          error
        };
      }

      return {
        error: false
      };
    });

    _defineProperty(this, "validateWrappedControl", field => {
      const t = this.props.t;
      const response = this.wrappedControlValid();

      if (typeof response === 'boolean') {
        const isValid = response;
        return {
          error: !isValid
        };
      } else if (response.hasOwnProperty('error')) {
        return response;
      } else if (response instanceof Promise) {
        response.then(() => {
          this.validate({
            error: false
          });
        }, err => {
          const error = {
            type: ValidationErrorTypes.CUSTOM,
            message: `${field.get('label', field.get('name'))} - ${err}.`
          };
          this.validate({
            error
          });
        });
        const error = {
          type: ValidationErrorTypes.CUSTOM,
          message: t('editor.editorControlPane.widget.processing', {
            fieldLabel: field.get('label', field.get('name'))
          })
        };
        return {
          error
        };
      }

      return {
        error: false
      };
    });

    _defineProperty(this, "getObjectValue", () => this.props.value || Map());

    _defineProperty(this, "onChangeObject", (fieldName, newValue, newMetadata) => {
      const newObjectValue = this.getObjectValue().set(fieldName, newValue);
      return this.props.onChange(newObjectValue, {
        [this.props.field.get('name')]: newMetadata
      });
    });
  }

  shouldComponentUpdate(nextProps) {
    /**
     * Allow widgets to provide their own `shouldComponentUpdate` method.
     */
    if (this.wrappedControlShouldComponentUpdate) {
      return this.wrappedControlShouldComponentUpdate(nextProps);
    }

    return this.props.value !== nextProps.value || this.props.classNameWrapper !== nextProps.classNameWrapper || this.props.hasActiveStyle !== nextProps.hasActiveStyle;
  }

  render() {
    const _this$props2 = this.props,
          controlComponent = _this$props2.controlComponent,
          field = _this$props2.field,
          value = _this$props2.value,
          mediaPaths = _this$props2.mediaPaths,
          metadata = _this$props2.metadata,
          onChange = _this$props2.onChange,
          onValidateObject = _this$props2.onValidateObject,
          onOpenMediaLibrary = _this$props2.onOpenMediaLibrary,
          onRemoveMediaControl = _this$props2.onRemoveMediaControl,
          onClearMediaControl = _this$props2.onClearMediaControl,
          onAddAsset = _this$props2.onAddAsset,
          onRemoveInsertedMedia = _this$props2.onRemoveInsertedMedia,
          getAsset = _this$props2.getAsset,
          classNameWrapper = _this$props2.classNameWrapper,
          classNameWidget = _this$props2.classNameWidget,
          classNameWidgetActive = _this$props2.classNameWidgetActive,
          classNameLabel = _this$props2.classNameLabel,
          classNameLabelActive = _this$props2.classNameLabelActive,
          setActiveStyle = _this$props2.setActiveStyle,
          setInactiveStyle = _this$props2.setInactiveStyle,
          hasActiveStyle = _this$props2.hasActiveStyle,
          editorControl = _this$props2.editorControl,
          uniqueFieldId = _this$props2.uniqueFieldId,
          resolveWidget = _this$props2.resolveWidget,
          getEditorComponents = _this$props2.getEditorComponents,
          query = _this$props2.query,
          queryHits = _this$props2.queryHits,
          clearSearch = _this$props2.clearSearch,
          clearFieldErrors = _this$props2.clearFieldErrors,
          isFetching = _this$props2.isFetching,
          loadEntry = _this$props2.loadEntry,
          fieldsErrors = _this$props2.fieldsErrors,
          controlRef = _this$props2.controlRef,
          t = _this$props2.t;
    return React.createElement(controlComponent, {
      field,
      value,
      mediaPaths,
      metadata,
      onChange,
      onChangeObject: this.onChangeObject,
      onValidateObject,
      onOpenMediaLibrary,
      onClearMediaControl,
      onRemoveMediaControl,
      onAddAsset,
      onRemoveInsertedMedia,
      getAsset,
      forID: uniqueFieldId,
      ref: this.processInnerControlRef,
      classNameWrapper,
      classNameWidget,
      classNameWidgetActive,
      classNameLabel,
      classNameLabelActive,
      setActiveStyle,
      setInactiveStyle,
      hasActiveStyle,
      editorControl,
      resolveWidget,
      getEditorComponents,
      query,
      queryHits,
      clearSearch,
      clearFieldErrors,
      isFetching,
      loadEntry,
      fieldsErrors,
      controlRef,
      t
    });
  }

}

_defineProperty(Widget, "propTypes", {
  controlComponent: PropTypes.func.isRequired,
  field: ImmutablePropTypes.map.isRequired,
  hasActiveStyle: PropTypes.bool,
  setActiveStyle: PropTypes.func.isRequired,
  setInactiveStyle: PropTypes.func.isRequired,
  classNameWrapper: PropTypes.string.isRequired,
  classNameWidget: PropTypes.string.isRequired,
  classNameWidgetActive: PropTypes.string.isRequired,
  classNameLabel: PropTypes.string.isRequired,
  classNameLabelActive: PropTypes.string.isRequired,
  value: PropTypes.oneOfType([PropTypes.node, PropTypes.object, PropTypes.string, PropTypes.bool]),
  mediaPaths: ImmutablePropTypes.map.isRequired,
  metadata: ImmutablePropTypes.map,
  fieldsErrors: ImmutablePropTypes.map,
  onChange: PropTypes.func.isRequired,
  onValidate: PropTypes.func,
  onOpenMediaLibrary: PropTypes.func.isRequired,
  onClearMediaControl: PropTypes.func.isRequired,
  onRemoveMediaControl: PropTypes.func.isRequired,
  onAddAsset: PropTypes.func.isRequired,
  onRemoveInsertedMedia: PropTypes.func.isRequired,
  getAsset: PropTypes.func.isRequired,
  resolveWidget: PropTypes.func.isRequired,
  getEditorComponents: PropTypes.func.isRequired,
  isFetching: PropTypes.bool,
  controlRef: PropTypes.func,
  query: PropTypes.func.isRequired,
  clearSearch: PropTypes.func.isRequired,
  clearFieldErrors: PropTypes.func.isRequired,
  queryHits: PropTypes.oneOfType([PropTypes.array, PropTypes.object]),
  editorControl: PropTypes.func.isRequired,
  uniqueFieldId: PropTypes.string.isRequired,
  loadEntry: PropTypes.func.isRequired,
  t: PropTypes.func.isRequired
});