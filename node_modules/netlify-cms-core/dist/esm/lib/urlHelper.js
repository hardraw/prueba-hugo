import _partialRight from "lodash/partialRight";
import _flow from "lodash/flow";
import _escapeRegExp from "lodash/escapeRegExp";
import _isString from "lodash/isString";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import url from 'url';
import diacritics from 'diacritics';
import sanitizeFilename from 'sanitize-filename';
import { Map } from 'immutable';

function getUrl(urlString, direct) {
  return `${direct ? '/#' : ''}${urlString}`;
}

export function getCollectionUrl(collectionName, direct) {
  return getUrl(`/collections/${collectionName}`, direct);
}
export function getNewEntryUrl(collectionName, direct) {
  return getUrl(`/collections/${collectionName}/new`, direct);
}
export function addParams(urlString, params) {
  const parsedUrl = url.parse(urlString, true);
  parsedUrl.query = _objectSpread({}, parsedUrl.query, params);
  return url.format(parsedUrl);
}
export function stripProtocol(urlString) {
  const protocolEndIndex = urlString.indexOf('//');
  return protocolEndIndex > -1 ? urlString.slice(protocolEndIndex + 2) : urlString;
}
/* See https://www.w3.org/International/articles/idn-and-iri/#path.
 * According to the new IRI (Internationalized Resource Identifier) spec, RFC 3987,
 *   ASCII chars should be kept the same way as in standard URIs (letters digits _ - . ~).
 * Non-ASCII chars (unless they are not in the allowed "ucschars" list) should be percent-encoded.
 * If the string is not encoded in Unicode, it should be converted to UTF-8 and normalized first,
 *   but JS stores strings as UTF-16/UCS-2 internally, so we should not normallize or re-encode.
 */

const uriChars = /[\w\-.~]/i;
const ucsChars = /(?:[\xA0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|[\uD800-\uD83E\uD840-\uD87E\uD880-\uD8BE\uD8C0-\uD8FE\uD900-\uD93E\uD940-\uD97E\uD980-\uD9BE\uD9C0-\uD9FE\uDA00-\uDA3E\uDA40-\uDA7E\uDA80-\uDABE\uDAC0-\uDAFE\uDB00-\uDB3E\uDB44-\uDB7E][\uDC00-\uDFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F][\uDC00-\uDFFD])/;

const validURIChar = char => uriChars.test(char);

const validIRIChar = char => uriChars.test(char) || ucsChars.test(char); // `sanitizeURI` does not actually URI-encode the chars (that is the browser's and server's job), just removes the ones that are not allowed.


export function sanitizeURI(str) {
  let _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$replacement = _ref.replacement,
      replacement = _ref$replacement === void 0 ? '' : _ref$replacement,
      _ref$encoding = _ref.encoding,
      encoding = _ref$encoding === void 0 ? 'unicode' : _ref$encoding;

  if (!_isString(str)) {
    throw new Error('The input slug must be a string.');
  }

  if (!_isString(replacement)) {
    throw new Error('`options.replacement` must be a string.');
  }

  let validChar;

  if (encoding === 'unicode') {
    validChar = validIRIChar;
  } else if (encoding === 'ascii') {
    validChar = validURIChar;
  } else {
    throw new Error('`options.encoding` must be "unicode" or "ascii".');
  } // Check and make sure the replacement character is actually a safe char itself.


  if (!Array.from(replacement).every(validChar)) {
    throw new Error('The replacement character(s) (options.replacement) is itself unsafe.');
  } // `Array.from` must be used instead of `String.split` because
  //   `split` converts things like emojis into UTF-16 surrogate pairs.


  return Array.from(str).map(char => validChar(char) ? char : replacement).join('');
}
export function sanitizeSlug(str) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Map();
  const encoding = options.get('encoding', 'unicode');
  const stripDiacritics = options.get('clean_accents', false);
  const replacement = options.get('sanitize_replacement', '-');

  if (!_isString(str)) {
    throw new Error('The input slug must be a string.');
  }

  const sanitizedSlug = _flow([...(stripDiacritics ? [diacritics.remove] : []), _partialRight(sanitizeURI, {
    replacement,
    encoding
  }), _partialRight(sanitizeFilename, {
    replacement
  })])(str); // Remove any doubled or leading/trailing replacement characters (that were added in the sanitizers).


  const doubleReplacement = new RegExp(`(?:${_escapeRegExp(replacement)})+`, 'g');
  const trailingReplacment = new RegExp(`${_escapeRegExp(replacement)}$`);
  const leadingReplacment = new RegExp(`^${_escapeRegExp(replacement)}`);
  const normalizedSlug = sanitizedSlug.replace(doubleReplacement, replacement).replace(leadingReplacment, '').replace(trailingReplacment, '');
  return normalizedSlug;
}