import _find from "lodash/find";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import PropTypes from 'prop-types';
import ImmutablePropTypes from 'react-immutable-proptypes';
import { Map, List, fromJS } from 'immutable';
import Select from 'react-select';
import { reactSelectStyles } from 'netlify-cms-ui-default';

function optionToString(option) {
  return option && option.value ? option.value : null;
}

function convertToOption(raw) {
  if (typeof raw === 'string') {
    return {
      label: raw,
      value: raw
    };
  }

  return Map.isMap(raw) ? raw.toJS() : raw;
}

function getSelectedValue(_ref) {
  let value = _ref.value,
      options = _ref.options,
      isMultiple = _ref.isMultiple;

  if (isMultiple) {
    const selectedOptions = List.isList(value) ? value.toJS() : value;

    if (!selectedOptions || !Array.isArray(selectedOptions)) {
      return null;
    }

    return selectedOptions.map(i => options.find(o => o.value === (i.value || i))).filter(Boolean).map(convertToOption);
  } else {
    return _find(options, ['value', value]) || null;
  }
}

export default class SelectControl extends React.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "handleChange", selectedOption => {
      const _this$props = this.props,
            onChange = _this$props.onChange,
            field = _this$props.field;
      const isMultiple = field.get('multiple', false);

      if (Array.isArray(selectedOption)) {
        if (!isMultiple && selectedOption.length === 0) {
          onChange(null);
        } else {
          onChange(fromJS(selectedOption.map(optionToString)));
        }
      } else {
        onChange(optionToString(selectedOption));
      }
    });
  }

  render() {
    const _this$props2 = this.props,
          field = _this$props2.field,
          value = _this$props2.value,
          forID = _this$props2.forID,
          classNameWrapper = _this$props2.classNameWrapper,
          setActiveStyle = _this$props2.setActiveStyle,
          setInactiveStyle = _this$props2.setInactiveStyle;
    const fieldOptions = field.get('options');
    const isMultiple = field.get('multiple', false);
    const isClearable = !field.get('required', true) || isMultiple;

    if (!fieldOptions) {
      return React.createElement("div", null, "Error rendering select control for ", field.get('name'), ": No options");
    }

    const options = [...fieldOptions.map(convertToOption)];
    const selectedValue = getSelectedValue({
      options,
      value,
      isMultiple
    });
    return React.createElement(Select, {
      inputId: forID,
      value: selectedValue,
      onChange: this.handleChange,
      className: classNameWrapper,
      onFocus: setActiveStyle,
      onBlur: setInactiveStyle,
      options: options,
      styles: reactSelectStyles,
      isMulti: isMultiple,
      isClearable: isClearable,
      placeholder: ""
    });
  }

}

_defineProperty(SelectControl, "propTypes", {
  onChange: PropTypes.func.isRequired,
  value: PropTypes.node,
  forID: PropTypes.string.isRequired,
  classNameWrapper: PropTypes.string.isRequired,
  setActiveStyle: PropTypes.func.isRequired,
  setInactiveStyle: PropTypes.func.isRequired,
  field: ImmutablePropTypes.contains({
    options: ImmutablePropTypes.listOf(PropTypes.oneOfType([PropTypes.string, ImmutablePropTypes.contains({
      label: PropTypes.string.isRequired,
      value: PropTypes.string.isRequired
    })])).isRequired
  })
});